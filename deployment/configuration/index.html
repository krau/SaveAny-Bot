<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  配置说明
  #

SaveAnyBot 的配置文件使用 toml 格式, 你可以在 TOML 官方网站 上了解更多关于 toml 的语法.
SaveAnyBot 需要读取工作目录下的 config.toml 文件作为配置文件, 若缺少该文件则会创建默认文件, 并尝试从环境变量中加载配置.
以下是一个最简的配置文件示例:
[telegram]
token = "1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"

[[users]]
# telegram user id
id = 777000
blacklist = true

[[storages]]
name = "本机存储"
type = "local"
enable = true
base_path = "./downloads"

  详细配置
  #


  全局配置
  #


stream: 是否启用 Stream 模式, 默认为 false. 启用后 Bot 将直接将文件流式传输到存储端(若存储端支持), 不需要下载到本地

  
Stream 模式对于磁盘空间有限的部署环境十分有用, 但也有一些弊端:


无法使用多线程从 Telegram 下载文件, 速度较慢.
网络不稳定时, 任务失败率高.
无法在中间层对文件进行处理, 例如自动文件类型识别.
并非支持所有存储端, 不支持的存储端可能会降级为普通模式或无法上传.




workers: 同时处理任务数量, 默认为 3
threads: 下载文件时使用的线程数, 默认为 4. 仅在未启用 Stream 模式时生效.
retry: 任务失败时的重试次数, 默认为 3.


  Telegram 配置
  #


token: 你的 Telegram Bot Token, 可以通过 BotFather 创建 Bot 并获取 Token.
app_id, app_hash: Telegram API ID & Hash, 在 Telegram API 创建应用获取, 若不提供则使用默认值.
flood_retry: Flood 控制重试次数, 默认为 5.
rpc_retry: RPC 请求重试次数, 默认为 5.
proxy: 代理配置, 可选项.

enable: 是否启用代理.
url: 代理地址, 只支持 socks5://



[telegram]
token = "1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
app_id = 1025907
app_hash = "452b0359b988148995f22ff0f4229750"
flood_retry = 5
rpc_retry = 5
[telegram.proxy]
enable = false
url = "socks5://127.0.0.1:7890"

  存储端列表
  #

存储端列表用于定义 Bot 支持的存储位置, 每个存储端需要指定名称、类型和相关配置, 使用双中括号语法 [[storages]] 定义.'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://sabot.unv.app/deployment/configuration/"><meta property="og:site_name" content="Save Any Bot"><meta property="og:title" content="配置说明"><meta property="og:description" content='配置说明 # SaveAnyBot 的配置文件使用 toml 格式, 你可以在 TOML 官方网站 上了解更多关于 toml 的语法.
SaveAnyBot 需要读取工作目录下的 config.toml 文件作为配置文件, 若缺少该文件则会创建默认文件, 并尝试从环境变量中加载配置.
以下是一个最简的配置文件示例:
[telegram] token = "1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ" [[users]] # telegram user id id = 777000 blacklist = true [[storages]] name = "本机存储" type = "local" enable = true base_path = "./downloads" 详细配置 # 全局配置 # stream: 是否启用 Stream 模式, 默认为 false. 启用后 Bot 将直接将文件流式传输到存储端(若存储端支持), 不需要下载到本地 Stream 模式对于磁盘空间有限的部署环境十分有用, 但也有一些弊端: 无法使用多线程从 Telegram 下载文件, 速度较慢. 网络不稳定时, 任务失败率高. 无法在中间层对文件进行处理, 例如自动文件类型识别. 并非支持所有存储端, 不支持的存储端可能会降级为普通模式或无法上传. workers: 同时处理任务数量, 默认为 3 threads: 下载文件时使用的线程数, 默认为 4. 仅在未启用 Stream 模式时生效. retry: 任务失败时的重试次数, 默认为 3. Telegram 配置 # token: 你的 Telegram Bot Token, 可以通过 BotFather 创建 Bot 并获取 Token. app_id, app_hash: Telegram API ID & Hash, 在 Telegram API 创建应用获取, 若不提供则使用默认值. flood_retry: Flood 控制重试次数, 默认为 5. rpc_retry: RPC 请求重试次数, 默认为 5. proxy: 代理配置, 可选项. enable: 是否启用代理. url: 代理地址, 只支持 socks5:// [telegram] token = "1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ" app_id = 1025907 app_hash = "452b0359b988148995f22ff0f4229750" flood_retry = 5 rpc_retry = 5 [telegram.proxy] enable = false url = "socks5://127.0.0.1:7890" 存储端列表 # 存储端列表用于定义 Bot 支持的存储位置, 每个存储端需要指定名称、类型和相关配置, 使用双中括号语法 [[storages]] 定义.'><meta property="og:locale" content="zh"><meta property="og:type" content="website"><title>配置说明 | Save Any Bot</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://sabot.unv.app/deployment/configuration/><link rel=alternate hreflang=en href=https://sabot.unv.app/en/deployment/configuration/ title="Configuration Guide"><link rel=stylesheet href=/book.min.a22f4c7d8c2bdc5e3d6e34ba11cb59ab50ea5772594e71305bfd5a595dc78b7e.css integrity="sha256-oi9MfYwr3F49bjS6EctZq1DqV3JZTnEwW/1aWV3Hi34=" crossorigin=anonymous><link rel=alternate type=application/rss+xml href=https://sabot.unv.app/deployment/configuration/index.xml title="Save Any Bot"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span>Save Any Bot</span></a></h2><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class=flex><a role=button class="flex flex-auto"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=/en/deployment/configuration/>English</a></li></ul></li></ul><ul><li><span>部署指南</span><ul><li><a href=/deployment/installation/>安装与更新</a></li><li><a href=/deployment/configuration/ class=active>配置说明</a><ul><li><a href=/deployment/configuration/storages/>存储端配置</a></li></ul></li></ul></li><li><a href=/usage/>使用帮助</a><ul></ul></li><li><a href=/help/>常见问题</a><ul></ul></li><li><a href=/contribute/>参与开发</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>配置说明</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#详细配置>详细配置</a><ul><li><a href=#全局配置>全局配置</a></li><li><a href=#telegram-配置>Telegram 配置</a></li><li><a href=#存储端列表>存储端列表</a></li><li><a href=#用户列表>用户列表</a></li><li><a href=#杂项>杂项</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=配置说明>配置说明
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e8%af%b4%e6%98%8e>#</a></h1><p>SaveAnyBot 的配置文件使用 toml 格式, 你可以在 <a href=https://toml.io/>TOML 官方网站</a> 上了解更多关于 toml 的语法.</p><p>SaveAnyBot 需要读取工作目录下的 <code>config.toml</code> 文件作为配置文件, 若缺少该文件则会创建默认文件, 并尝试从环境变量中加载配置.</p><p>以下是一个最简的配置文件示例:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>telegram</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>token</span> = <span style=color:#e6db74>&#34;1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>users</span>]]
</span></span><span style=display:flex><span><span style=color:#75715e># telegram user id</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>id</span> = <span style=color:#ae81ff>777000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blacklist</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>storages</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;本机存储&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> = <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>enable</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>base_path</span> = <span style=color:#e6db74>&#34;./downloads&#34;</span>
</span></span></code></pre></div><h2 id=详细配置>详细配置
<a class=anchor href=#%e8%af%a6%e7%bb%86%e9%85%8d%e7%bd%ae>#</a></h2><h3 id=全局配置>全局配置
<a class=anchor href=#%e5%85%a8%e5%b1%80%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><code>stream</code>: 是否启用 Stream 模式, 默认为 <code>false</code>. 启用后 Bot 将直接将文件流式传输到存储端(若存储端支持), 不需要下载到本地<blockquote class="book-hint warning">Stream 模式对于磁盘空间有限的部署环境十分有用, 但也有一些弊端:<br><ul><li>无法使用多线程从 Telegram 下载文件, 速度较慢.</li><li>网络不稳定时, 任务失败率高.</li><li>无法在中间层对文件进行处理, 例如自动文件类型识别.</li><li>并非支持所有存储端, 不支持的存储端可能会降级为普通模式或无法上传.</li></ul></blockquote></li><li><code>workers</code>: 同时处理任务数量, 默认为 3</li><li><code>threads</code>: 下载文件时使用的线程数, 默认为 4. 仅在未启用 Stream 模式时生效.</li><li><code>retry</code>: 任务失败时的重试次数, 默认为 3.</li></ul><h3 id=telegram-配置>Telegram 配置
<a class=anchor href=#telegram-%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><code>token</code>: 你的 Telegram Bot Token, 可以通过 <a href=https://t.me/botfather>BotFather</a> 创建 Bot 并获取 Token.</li><li><code>app_id</code>, <code>app_hash</code>: Telegram API ID & Hash, 在 <a href=https://my.telegram.org/apps>Telegram API</a> 创建应用获取, 若不提供则使用默认值.</li><li><code>flood_retry</code>: Flood 控制重试次数, 默认为 5.</li><li><code>rpc_retry</code>: RPC 请求重试次数, 默认为 5.</li><li><code>proxy</code>: 代理配置, 可选项.<ul><li><code>enable</code>: 是否启用代理.</li><li><code>url</code>: 代理地址, 只支持 <code>socks5://</code></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>telegram</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>token</span> = <span style=color:#e6db74>&#34;1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app_id</span> = <span style=color:#ae81ff>1025907</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app_hash</span> = <span style=color:#e6db74>&#34;452b0359b988148995f22ff0f4229750&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>flood_retry</span> = <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rpc_retry</span> = <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>telegram</span>.<span style=color:#a6e22e>proxy</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>enable</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>url</span> = <span style=color:#e6db74>&#34;socks5://127.0.0.1:7890&#34;</span>
</span></span></code></pre></div><h3 id=存储端列表>存储端列表
<a class=anchor href=#%e5%ad%98%e5%82%a8%e7%ab%af%e5%88%97%e8%a1%a8>#</a></h3><p>存储端列表用于定义 Bot 支持的存储位置, 每个存储端需要指定名称、类型和相关配置, 使用双中括号语法 <code>[[storages]]</code> 定义.</p><p>每一个存储端至少需要以下字段:</p><ul><li><code>name</code>: 存储端名称, 用于在 Bot 中识别, 需要唯一</li><li><code>enable</code>: 是否启用该存储端, 默认为 <code>true</code></li><li><code>type</code>: 存储端类型, 目前支持以下类型:<ul><li><code>local</code>: 本地磁盘</li><li><code>alist</code>: Alist</li><li><code>webdav</code>: WebDAV</li><li><code>minio</code>: MinIO (兼容 S3 API)</li><li><code>telegram</code>: 上传到 Telegram</li></ul></li></ul><p>示例, 这是一个包含本地存储和 webdav 存储的配置:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[[<span style=color:#a6e22e>storages</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;本地存储&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> = <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>enable</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 以下是 local 类型存储的自定义配置</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>base_path</span> = <span style=color:#e6db74>&#34;./downloads&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>storages</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;WebDAV&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> = <span style=color:#e6db74>&#34;webdav&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>enable</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 以下是 webdav 类型存储的自定义配置</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>url</span> = <span style=color:#e6db74>&#34;https://example.com/webdav&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>base_path</span> = <span style=color:#e6db74>&#34;/path/to/webdav&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>username</span> = <span style=color:#e6db74>&#34;your_username&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>password</span> = <span style=color:#e6db74>&#34;your_password&#34;</span>
</span></span></code></pre></div><p>所有存储端的自定义配置项可查看 <a href=./storages>存储端配置</a></p><h3 id=用户列表>用户列表
<a class=anchor href=#%e7%94%a8%e6%88%b7%e5%88%97%e8%a1%a8>#</a></h3><p>用户列表用于定义对存储端的访问控制, 每个用户需要指定 Telegram 上的用户 ID, 使用双中括号语法 <code>[[users]]</code> 定义.</p><ul><li><code>id</code>: 用户的 Telegram User ID</li><li><code>storages</code>: 过滤的存储端列表, 使用存储端名称定义, 默认为白名单模式 (即只允许访问列表中的存储端)</li><li><code>blacklist</code>: 是否启用黑名单模式, 默认为 <code>false</code>. 若启用黑名单模式, 则仅允许访问<strong>没有</strong>在列表中的存储端.</li></ul><p>示例, 这是一个包含三个用户的配置, 用户 <code>123123</code> 只能访问本地存储, 用户 <code>456456</code> 只能访问除 WebDAV 以外的存储, 用户 <code>789789</code> 启用黑名单模式但没有指定存储端, 因此可以访问所有存储:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[[<span style=color:#a6e22e>users</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>id</span> = <span style=color:#ae81ff>123123</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>storages</span> = [<span style=color:#e6db74>&#34;本地存储&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>users</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>id</span> = <span style=color:#ae81ff>456456</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>storages</span> = [<span style=color:#e6db74>&#34;WebDAV&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>blacklist</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[[<span style=color:#a6e22e>users</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>id</span> = <span style=color:#ae81ff>789789</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>storages</span> = []
</span></span><span style=display:flex><span><span style=color:#a6e22e>blacklist</span> = <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><h3 id=杂项>杂项
<a class=anchor href=#%e6%9d%82%e9%a1%b9>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#a6e22e>no_clean_cache</span> = <span style=color:#66d9ef>false</span> <span style=color:#75715e># 是否在退出时不清空缓存文件夹</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 临时下载文件夹配置</span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>temp</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>base_path</span> = <span style=color:#e6db74>&#34;./cache&#34;</span>
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/krau/saveany-bot/commit/4206d1fe9658e4f240e426827d65611ea33ab0ed title='最后修改者 krau | 2025/06/16' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2025/06/16</span></a></div><div><a class="flex align-center" href=https://github.com/krau/saveany-bot/edit/main/docs/content/zh/deployment/configuration/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#详细配置>详细配置</a><ul><li><a href=#全局配置>全局配置</a></li><li><a href=#telegram-配置>Telegram 配置</a></li><li><a href=#存储端列表>存储端列表</a></li><li><a href=#用户列表>用户列表</a></li><li><a href=#杂项>杂项</a></li></ul></li></ul></nav></div></aside></main></body></html>