// cmd/geni18n/main.go
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

func main() {
	dir := flag.String("dir", "./common/i18n/locale", "Locales directory path")
	out := flag.String("out", "common/i18n/i18nk/keys.go", "Output file path")
	pkg := flag.String("pkg", "i18nk", "Package name for generated file")
	flag.Parse()

	keys := make(map[string]struct{})
	re := regexp.MustCompile(`^\s*\[+\s*([^\]\[]+)\s*\]+`)

	err := filepath.WalkDir(*dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() || !strings.HasSuffix(d.Name(), ".toml") {
			return nil
		}
		f, err := os.Open(path)
		if err != nil {
			return err
		}
		defer f.Close()

		s := bufio.NewScanner(f)
		for s.Scan() {
			if m := re.FindStringSubmatch(s.Text()); m != nil {
				keys[m[1]] = struct{}{}
			}
		}
		return s.Err()
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error walking directory: %v\n", err)
		os.Exit(1)
	}

	var list []string
	for k := range keys {
		list = append(list, k)
	}
	sort.Strings(list)

	f, err := os.Create(*out)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	fmt.Fprintf(w, "// Code generated by cmd/gen_i18n. DO NOT EDIT.\n")
	fmt.Fprintf(w, "package %s\n\n", *pkg)
	fmt.Fprintf(w, "const (\n")
	for _, key := range list {
		name := toPascal(key)
		fmt.Fprintf(w, "\t%s = %q\n", name, key)
	}
	fmt.Fprintf(w, ")\n")
	w.Flush()
}

func toPascal(key string) string {
	parts := strings.Split(key, ".")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(string(p[0])) + p[1:]
		}
	}
	return strings.Join(parts, "")
}
